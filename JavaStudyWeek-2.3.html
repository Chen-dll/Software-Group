<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608491 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <meta name="application-data:yinxiang.noteLayout" content="{"autoLayoutWidth":0,"autoLineSpace":"recommend","autoParagraphSpace":"recommend","autoTitleWordSize":28}"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="826"/>

<div><span><h2 style="other-props:eyJibG9ja0lkIjoiUkNtb1NXcm5BdGEifQ==;">面向对象</h2><ul><li><div>案例</div></li><li><div>对于操作类里面写了有参数构造器后需不需要添加无参数构造器，一般是可以不用，因为都是在             <code style="-en-code: true">main</code> 方法里 <code style="-en-code: true">new</code> 的时候直接在小括号里传数据，然后通过有参数构造器里面对<code style="-en-code: true">this.</code> 赋值，不会只写个()，但是如果出现这种情况，就会提示报错，就需要加上无参数构造器。</div></li><li><div>而实体就一定要有无参数构造器了，这是他的格式要求。</div></li><li><div>实体中有参数构造器有没有都行，无参数构造器默认自带，但是<b>只写了有参数构造器后，就要另外加上无参数构造器</b>。全部都可以右键生成，要无参数的就全不选。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image.png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.3_files/Image [1].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><ul><li><div><b>成员变量和局部变量区别</b></div></li><li><div>局部变量无初始化，动态数组的对象有初始化的。就是<code style="-en-code: true">int[] a = new int[3];</code> 里面是全赋0。</div></li><li><div>成员变量，是在<code style="-en-code: true">main</code> 方法里，栈内存，就是单独一个地址或是个值，没有开辟堆内存，所以是符合先进后出的的栈内存。</div></li><li><div>关于生存周期，其实本质都是作用域的问题，在大括号里生存，成员变量也是在对象消失后死亡，对象其实就是一个类，一个封装了变量和方法的类。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [2].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><h2 style="other-props:eyJibG9ja0lkIjoiazJiZlJ5RFBMcEkifQ==;">方法和面向对象的总结</h2><h3 style="other-props:eyJibG9ja0lkIjoibGFnRFRxWnByZmwifQ==;"> 方法</h3><img src="JavaStudyWeek-2.3_files/Image [3].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.3_files/Image [4].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.3_files/Image [5].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.3_files/Image [6].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>前面落了一块方法重载和<code style="-en-code: true">return;</code> 关键字，这里补上</div></li><li><div>方法重载，就是同一个类里面可以有同样名字的方法，但是传进去的参数不一样（形参列表不同），会自动按照参数匹配的，其他的修饰符还有别的返回值什么的都不管，形参也只考虑个数、类型、顺序，不管叫什么名称。</div></li><li><div>修饰符 <code style="-en-code: true">public</code>  就是公共，<code style="-en-code: true">static</code> 就是全局。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [7].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.3_files/Image [8].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>重载就是易读，而且方便调用，会有提示。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [9].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>也是可以设定默认值</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [10].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>小总结（专业、方便）</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [11].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div><code style="-en-code: true">return</code> 关键字，和C语言一样，没啥特别的</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [12].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3 style="other-props:eyJibG9ja0lkIjoiMzNuNlNXQnNuRloifQ==;"> 面向对象编程（oop）</h3><img src="JavaStudyWeek-2.3_files/Image [13].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.3_files/Image [14].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>不建议给初始化值，是因为引用的时候还要传值，除非是结构体那个变量都要求同一个特殊初始值。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [15].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.3_files/Image [16].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div><code style="-en-code: true">new</code> 的是构造器，构造器实际上是返回地址给栈内存的对象名保存。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [17].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>重点（弹幕的话其实就是包括两种，只要你定义了构造器，系统就不会自动创建了，但是你（在定义了有参数构造器后）又是还想要无参数构造器，那就得自己搞）</div></li></ul><ul><li><div><code style="-en-code: true">this</code> 关键字也很常用，在赋值或者是重名的时候用。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [18].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><ul><li><div>在操作类里的构造器，来给操作类里面声明的实体类变量赋值，在<code style="-en-code: true">main</code> 方法里面给操作类传实体类名（在此之前<code style="-en-code: true">new</code> 了实体变量，赋了值后传给操作类，然后可以调用操作类里面的方法）</div></li></ul></ul><img src="JavaStudyWeek-2.3_files/Image [19].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><ul><li><div>在重名的时候，这里传给方法的是及格线，然后这个方法是在<code style="-en-code: true">Student</code> 类里面的，在<code style="-en-code: true">main</code> 方法里面 <code style="-en-code: true">new</code> 了类，赋值操作填入数据后，然后<code style="-en-code: true">类名.方法</code> 调用这个方法，给出及格线后，           <code style="-en-code: true">this.score</code> 就是调用目前对象，也就是新建的类里面的的<code style="-en-code: true">score</code> 数据，与传入方法的及格线进行比较。</div></li></ul></ul><img src="JavaStudyWeek-2.3_files/Image [20].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>封装思想</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [21].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>实体类（标准JavaBean）&amp; 局部变量和成员变量的区别</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [22].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2 style="other-props:eyJibG9ja0lkIjoiN1ZLT1JTNHBYLUMifQ==;">常用API</h2><ul><li><div>API中文文档<code style="-en-code: true">https://cunzaima.cn/</code></div></li></ul><ul><li><div>别人写好的程序，就不要自己再写了，要直接拿过来用。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [23].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>需要学习的：IO包，lang包，NIO包，NET包，text包，time包，util包</div></li><li><div><b>包</b></div></li></ul><img src="JavaStudyWeek-2.3_files/Image [24].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>导包的注意事项</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [25].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div><code style="-en-code: true">java.lang</code> 包不用另外导</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [26].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>不同包里面有重名的类，默认只能导一个，其余的带全包名使用。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [27].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.3_files/Image [28].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3 style="other-props:eyJibG9ja0lkIjoiWURFWlNTdEQ1X08ifQ==;">String</h3><img src="JavaStudyWeek-2.3_files/Image [29].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>常见构造器</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [30].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div><code style="-en-code: true">name</code> 里面确实是字符串对象的地址，但是打印的时候会自动找到地址对应的内容打印。</div></li><li><div><code style="-en-code: true">String</code> 类里面的 <code style="-en-code: true">toString</code> 方法给重写了。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [31].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.3_files/Image [32].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>不推荐用第二种方法（不建议类比以前的声明数组的操作就是<code style="-en-code: true">new String(&quot;abc&quot;)</code> ）</div></li><li><div><b>直接双引号包住</b>就完事了，和C一样方便。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [33].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>常见的四种构造器（字符数组和字节数组都可以给构造器数组名然后构建字符串）</div></li><li><div><code style="-en-code: true">byte</code> 数组是根据<code style="-en-code: true">ASCLL</code> 码表来转换的。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [34].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>常用的<code style="-en-code: true">String</code> 类方法</div></li><li><div>运用这些方法去解决案例，才能快速熟悉，不然记不住。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [35].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div><code style="-en-code: true">.length</code> 按宽字节编码来统计字符数量，<b>一个中文字符</b>两个字节，<b>是一个字符</b>。</div></li><li><div>可以用<code style="-en-code: true">.charAt(i)</code> 来获取对应索引位置的字符，然后实现字符串里面逐个字符的输出</div></li><li><div>可以用<code style="-en-code: true">.toCharArray()</code>  比如 <code style="-en-code: true">char[] chars = s.toCharArray();</code> 把字符串转为字符数组，然后可以再遍历，输出</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [36].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>不能直接用<code style="-en-code: true">s1==s2</code> 来判断字符串相等，这比较的是地址，会输出<code style="-en-code: true">false</code> 前提是用<code style="-en-code: true">new String</code> 来赋值了，实际上构造器把地址给了<code style="-en-code: true">s1</code> 和<code style="-en-code: true">s2</code> 。（如果直接双引号引起来，那就是输出<code style="-en-code: true">true</code> 了）</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [37].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>输出<code style="-en-code: true">false</code> 因为地址不一样。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [38].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>输出<code style="-en-code: true">true</code> 因为重写了<code style="-en-code: true">toString</code> 方法</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [39].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>正确的应该是调用 <code style="-en-code: true">.equals()</code> 方法来比较，输出<code style="-en-code: true">true</code> </div></li></ul><img src="JavaStudyWeek-2.3_files/Image [40].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>注意字符串不能与其它类型转换后的字符串相比较</div></li><li><div><code style="-en-code: true">.equalsIgnoreCase()</code> 忽略大小写，经常用于比较验证码。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [41].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div><code style="-en-code: true">.subString()</code> 索引包前不包后，前面的索引就是包括的，选中看是多少个字符然后减一，后面的索引看下方是几个字符就填几。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [42].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>只填前面的索引就会一直输出到末尾</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [43].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>例子，输出<code style="-en-code: true">World</code> </div></li></ul><img src="JavaStudyWeek-2.3_files/Image [44].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><ul><li><div>切片 (python)</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [45].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.3_files/Image [46].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div><code style="-en-code: true">.replace()</code> 方法，第一个参数是字符串中要替换的字符，第二个是要替换成什么字符</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [47].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div><code style="-en-code: true">.contains()</code> 方法，判断字符串有没有给到方法的关键字，然后返回布尔值，精准匹配，大小写也要对应。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [48].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div><code style="-en-code: true">.startsWith()</code> 方法，判断字符串是不是以某个字符串开头，一般用于判断姓氏。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [49].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div><code style="-en-code: true">.split()</code> 方法，把字符串按照某个指定内容分割为多个字符串，放到一个字符串数组里面返回。</div></li><li><div>例子中原字符串姓名按照都好分隔，想提取单独的姓名字符串，存到一个字符串数组里面，就这样写。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [50].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>注意事项</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [51].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div><code style="-en-code: true">+=</code> 实际上是产生了新的字符串对象，然后把那个对象的地址转给栈内存的变量储存，原本的字符串对象是不变的，只是改变了栈内存变量存的地址，而地址是指向新对象的，原来的（刚开始声明的对象的内容存在字符串常量池）里面，并不会改变。只要不是双引号给的（比如<code style="-en-code: true">+=</code> <code style="-en-code: true">-=</code> ），就是新创建一个对象，原来的对象也不变，只是没有变量存它的地址，变成垃圾给自动回收了。</div></li><li><div>此处在后面也有提到，利用了<code style="-en-code: true">StringBuilder</code> ，本质是一个可变的字符数组来完成拼接，之后创建新的字符串对象提供新地址给原有变量储存。</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [52].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>第二点就是前面不同声明方式会有差别的原理</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [53].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><ul><li><div>弹幕说会有优化，说<code style="-en-code: true">s1==s2</code> 是比较<code style="-en-code: true">s1</code> ,<code style="-en-code: true">s2</code> 的内容而不是地址，可以说是乱讲，还是比较的地址，只是同一个常量是共用一个地址，此处 <code style="-en-code: true">s1</code> <code style="-en-code: true">s2</code> 存的地址是一样的，都是常量池里面的<code style="-en-code: true">abc</code> ，所以输出<code style="-en-code: true">true</code> </div></li></ul><img src="JavaStudyWeek-2.3_files/Image [54].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.3_files/Image [55].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>如图所示</div></li></ul><img src="JavaStudyWeek-2.3_files/Image [56].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div></span>
</div></body></html> 