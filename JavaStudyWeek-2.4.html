<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608491 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <meta name="application-data:yinxiang.noteLayout" content="{"autoLayoutWidth":0,"autoLineSpace":"recommend","autoParagraphSpace":"recommend","autoTitleWordSize":28}"/>
  <style>
	body, td {
	  font-family: 微软雅黑;
	  font-size: 12pt;
	}
  </style>
</head>
<body>
<a name="966"/>

<div><span><h2 style="other-props:eyJibG9ja0lkIjoieFRsMlFXN0dQX0wifQ==;">API:String</h2><ul><li><div>两种声明方式内存原理</div></li><li><div>用<code style="-en-code: true">“”</code> 定义，节省内存</div></li></ul><img src="JavaStudyWeek-2.4_files/Image.png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>通过<code style="-en-code: true">new 构造器</code> 定义</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [1].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>小总结</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [2].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>面试题1，双引号里面的都会存到常量池算一个对象，<code style="-en-code: true">new</code> 又会在堆内存新创建一个对象，然后把这个对象的地址给<code style="-en-code: true">s2</code> 储存。创建2个对象。</div></li><li><div>如果没有上面那行，就是只创建一个对象放在字符串常量池，创建1个对象。</div></li><li><div>但如果有，就直接取字符串常量池里面的地址给了<code style="-en-code: true">s1</code> 储存。创建0个对象</div></li><li><div>最后一行代码输出的应该是<code style="-en-code: true">false</code> ，因为两个变量储存的地址不一样。</div></li><li><div>字符串常量池<code style="-en-code: true">&quot;abc&quot;</code> 的也要算作一个对象。</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [3].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>面试题2，字符串只要是在运算，就会新建一个对象。但是你一行写下来一些确定的字面量相运算          比如<code style="-en-code: true">&quot;a&quot;+&quot;b&quot;+&quot;c&quot;</code> ，那就会自动优化成 <code style="-en-code: true">&quot;abc&quot;</code> ，也是为了节省内存，所以下面那个都是指向字符串常量池里的<code style="-en-code: true">&quot;abc&quot;</code> ，没有在堆内存新创建一个对象。</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [4].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>另一个案例</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [5].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.4_files/Image [6].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><ul><li><div>一共就是 临时的<code style="-en-code: true">StringBuilder</code> 对象 加上 <code style="-en-code: true">toString()</code> 方法生成的新的 <code style="-en-code: true">String</code>  对象。</div></li></ul></ul><img src="JavaStudyWeek-2.4_files/Image [7].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.4_files/Image [8].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.4_files/Image [9].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>内存的对象分析，创建一个新对象（本质上是一个字符数组）储存<code style="-en-code: true">name2</code> 的数据，然后往字符数组的后面加上经过编译优化后的<code style="-en-code: true">HeShe</code> ，最后将这个对象转为 <code style="-en-code: true">String</code> 类型，提供给<code style="-en-code: true">name</code> </div></li></ul><img src="JavaStudyWeek-2.4_files/Image [10].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div><code style="-en-code: true">StringBuilder</code> 的具体实现</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [11].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.4_files/Image [12].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.4_files/Image [13].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>也就是说，编译的时候如果遇到变量名，并不知道其指向的数据，所以只当作是一个符号，无法优化，但如果都是字面量的运算，那就可以优化。</div></li><li><div>案例：登陆界面</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [14].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.4_files/Image [15].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>从 <code style="-en-code: true">Scanner</code> 对象获得的数据不在字符串常量里面，而是在堆内存里面，用<code style="-en-code: true">==</code> 是比较地址，地址肯定不一样，不管账号密码是否正确，会一直返回<code style="-en-code: true">false</code> </div></li></ul><img src="JavaStudyWeek-2.4_files/Image [16].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>优雅操作</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [17].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>小总结</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [18].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><ul><li><div>再学个数据库 <code style="-en-code: true">Mysql</code> ，后端的题目就大差不差了。</div></li><li><div>案例：验证码（以前写过）</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [19].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>对于弹幕中的问题，肯定是在堆内存里面，只有那一长串双引号引起来的的再字符串常量池里面，每循环一次就要新建一个字符串对象来储存。（涉及前面提到的<code style="-en-code: true">StringBuilder</code> )</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [20].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2 style="other-props:eyJibG9ja0lkIjoib21zclJ1bmJuc3cifQ==;">API:ArrayList</h2><ul><li><div>类似于动态数组，或者是 C++提供的stl，<code style="-en-code: true">vector</code></div></li></ul><img src="JavaStudyWeek-2.4_files/Image [21].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>学习方法论</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [22].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div> 泛型类，在使用其创建对象的时候，可以在<code style="-en-code: true">&lt;&gt;</code> 里面规定数据类型，然后就只能储存这个类型了，如果不规定，那就随便装。</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [23].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>基本声明方法，最常用的是第一种</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [24].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.4_files/Image [25].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>输出跟<code style="-en-code: true">String</code> 一样</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [26].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>一般是希望能约束存储的数据类型的，蓝色部分为较规范的创建。</div></li><li><div><code style="-en-code: true">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</code> </div></li></ul><img src="JavaStudyWeek-2.4_files/Image [27].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>使用例子，<code style="-en-code: true">remove()</code> 里指定要删除的变量，是默认删除从左往右出现的第一个。</div></li><li><div>对于弹幕中要删除 只能存整形的动态数组里面的变量，<code style="-en-code: true">remove()</code> 会判断为索引还是值，这个前提就不存在，因为<code style="-en-code: true">ArrayList</code> 是泛型，不支持原始数据类型（<code style="-en-code: true">int</code> <code style="-en-code: true">double</code> <code style="-en-code: true">char</code> <code style="-en-code: true">byte</code> <code style="-en-code: true">short</code> ）等，泛型只能和引用类型一起使用。</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [28].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.4_files/Image [29].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.4_files/Image [30].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>总结</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [31].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.4_files/Image [32].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.4_files/Image [33].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>对于要存基本数据类型，提供了以下操作</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [34].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>回到上面弹幕的问题，有两种方案</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [35].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>如果照写，会优先按照索引的方法（可能会越界），但是显示写法或者类型转换是更加安全的方法。</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [36].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>模糊查找数组里的元素并删除的方法</div></li><li><div>下图的不行，因为删除后索引会变，被删除的后面会往前移，每删一次就漏遍历一个。</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [37].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>解决方案一，每次删除后<code style="-en-code: true">i--</code> 让索引回退到被删后，相邻的往前移的元素，这样就能遍历整个数组，而不会跳过往前移的部分。对于被删元素是第一个，删完之后索引变成 <code style="-en-code: true">i=-1</code> ，再参与循环的时候，    <code style="-en-code: true">i++</code> 后就是<code style="-en-code: true">i=0</code> ，就相当于索引还是0，</div></li><li><div>说白了就是一退一加回到被删索引的位置，在第2个位置被删就推到第1个位置后再加回到第2个位置，那么此时索引指的就是被删除之后，本来会被跳过的那个相邻元素。</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [38].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>循环中 <code style="-en-code: true">i++</code> 和 <code style="-en-code: true">++i</code> 的区别（没啥区别）</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [39].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>解决方法二，从集合的后面倒着遍历</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [40].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>注意<code style="-en-code: true">for</code> 循环是在执行完循环体后，再进行<code style="-en-code: true">i--</code> <code style="-en-code: true">i++</code> 等的操作的</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [41].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>总结</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [42].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>此处回顾一下创建实体数组</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [43].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.4_files/Image [44].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.4_files/Image [45].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>现在升级成 <code style="-en-code: true">ArrayList 实体类数组</code> </div></li></ul><img src="JavaStudyWeek-2.4_files/Image [46].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>面向对象的方法不加修饰符 <code style="-en-code: true">static</code> 全局</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [47].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="JavaStudyWeek-2.4_files/Image [48].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>接用户输入时不要接整数，尽量接字符串，因为用户乱输程序就崩了，接字符串，里面的数字在<code style="-en-code: true">case</code> 里面要拿<code style="-en-code: true">&quot;1&quot;</code> 表示字符</div></li></ul><img src="JavaStudyWeek-2.4_files/Image [49].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div></span>
</div></body></html> 